#!/usr/bin/env python3
#
#  WiFi-Monitor
#  T2_Linux
#
#  Created by turannul on 07/02/2026.
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; version 2 of the License.
#
#  See the LICENSE file for more details.

import logging
import re
import subprocess
import t2
import time
from typing import Pattern

# initialize logger
t2_logger = t2.setup_logging("WiFi-Guardian", level=logging.DEBUG)


def _log(log_level: str, event_msg: str) -> None:
    """Log a message with a specific log level format using shared logger."""
    t2.log_event(t2_logger, log_level, event_msg)


services: list[str] = ["NetworkManager", "bluetooth"]
modules: list[str] = ["brcmfmac", "hci_bcm4377"]
cd_time = 30

# regex pattern to match fatal errors (from my own experience):
patterns: list[str] = [
    r"CMD_TRIGGER_SCAN.*error.*\(5\)",  # - CMD_TRIGGER_SCAN error (5): I/O Error during scan start
    r"brcmf_msgbuf_query_dcmd",  # - query_dcmd: Firmware timeout (Hang)
    r"set wpa_auth failed",  # - set wpa_auth failed: Crypto offload failure
    r"error \(-12\)"  # - error (-12): ENOMEM (Memory allocation failure)
]


def _exec_cmd(command: str) -> bool:
    """Execute a shell command and return success status."""
    try:
        _log("#", f"Executing: {command}")
        res = t2.run_command(command, shell=True, check=True)
        return res.returncode == 0
    except subprocess.CalledProcessError:
        _log("!", f"Command failed: {command}")
        return False
    except Exception as e:
        _log("!", f"Command failed with error: {e}")
        return False


def _unload() -> bool:
    try:
        _log("+", "STAGE 1: Unloading...")
        # stop service first then, unload driver.
        for s in reversed(services):
            _log("+", f"Stopping Service: {s}")
            _exec_cmd(f"systemctl stop {s}")
        for m in reversed(modules):
            _log("+", f"Unloading module {m}...")
            # using --remove-holders to be safe, similar to modprobe --remove
            _exec_cmd(f"modprobe --remove --remove-holders {m}")
        # unloaded waiting hw to power off. (5 seconds)
        time.sleep(5)
        return True
    except Exception as err:
        _log("-", f"Unload unsucessful: {err}")
        return False


def _load() -> bool:
    try:
        _log("+", "STAGE 2: Loading...")
        # load driver first then, [re]start service
        for m in modules:
            _log("+", f"Loading module {m}...")
            _exec_cmd(f"modprobe --verbose {m}")
        for s in services:
            _log("+", f"Starting Service: {s}")
            _exec_cmd(f"systemctl start {s}")
        return True
    except Exception as err:
        _log("-", f"Load unsucessful: {err}")
        return False


# if you know you know ;) [tip: deadpool movie reference]
def al_is_watching() -> None:
    """Monitors the kernel ring buffer in real-time via journalctl."""
    _log("+", "Starting WiFi Guardian Monitor...")
    _log("#", f"Watching for patterns: {patterns}")

    compiled_patterns: list[Pattern[str]] = [re.compile(p, re.IGNORECASE) for p in patterns]
    last_recovery_time = 0

    try:
        # popen is different from run_cmd, stick to subprocess for persistent pipe
        p = subprocess.Popen(['journalctl', '-k', '-f', '-n', '0', '--no-pager'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=1)

        if p.stdout is None:
            _log("-", f"Failed to open journalctl stdout. Error: {p.stderr}")
            return

        for line in p.stdout:
            if not line:
                continue

            for pattern in compiled_patterns:
                if pattern.search(line):
                    # check if we are in a post-recovery cooldown period.
                    if time.time() - last_recovery_time < cd_time:
                        _log("+", "Error detected, but cooldown is active. Skipping reset.")
                        break

                    _log("#", f"PATTERN MATCHED: {pattern}")
                    _log("-", f"TRIGGER MATCHED: {line.strip()}")
                    _log("-", "CRITICAL HARDWARE HANG DETECTED. Initiating Nuclear Reset...")
                    _unload()
                    _load()
                    _log("+", "Reset sequence complete. Monitoring for stability...")

                    last_recovery_time = time.time()
                    break

    except PermissionError:
        _log("-", "Error: Permission denied. Run as root?")
    except Exception as err:
        _log("!", f"Unexpected monitor error: {err}")


if __name__ == "__main__":
    # auto-elevate if not root
    t2.check_root()
    al_is_watching()
