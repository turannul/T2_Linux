#!/usr/bin/env python3
#
#  suspendfix
#  T2_Linux
#
#  Created by turannul on 10/12/2025.
#  Rewritten in Python on 07/02/2026.
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; version 2 of the License.
#
#  See the LICENSE file for more details.

import argparse
import os
import subprocess
import sys
import time
from typing import List, Optional, Any
import logging

# constants

version = "0.5.2"

# import common utils
def import_t2():
    import sys
    import os
    # Check common installation paths
    for path in ["/usr/local/sbin", "/usr/local/lib"]:
        if path not in sys.path:
            sys.path.append(path)
    try:
        import t2
        return t2
    except ImportError:
        # fallback for dev environment
        script_dir = os.path.dirname(os.path.abspath(__file__))
        sys.path.append(os.path.join(script_dir, "..", "common"))
        try:
            import t2
            return t2
        except ImportError:
            print("Error: Could not import t2.py.")
            sys.exit(1)

t2 = import_t2()

# initialize global logger
logger = t2.setup_logging("SuspendFix")


def _log(char, msg) -> None:
    t2.log_event(logger, char, msg)


def get_active_user() -> tuple[None, None] | tuple[str, str]:
    try:
        output: str = subprocess.check_output(["loginctl", "list-users", "--no-legend"], text=True).strip()
        if not output:
            return None, None
        parts: List[str] = output.splitlines()[0].split()
        if len(parts) >= 2:
            user: str = parts[1]
            uid: str = subprocess.check_output(["id", "-u", user], text=True).strip()
            return user, uid
    except Exception as e:
        logger.debug(f"Failed to get active user: {e}")
    return None, None


target_user, target_uid = get_active_user()


def run_cmd_wrapper(cmd: List[str], check: bool = False, user_mode: bool = False) -> subprocess.CompletedProcess[Any] | subprocess.CompletedProcess[str]:
    if user_mode:
        if not target_user:
            logger.warning(f"No active user found for command: {' '.join(cmd)}")
            return subprocess.CompletedProcess(cmd, 1)
        env: dict[str, str] = os.environ.copy()
        env["XDG_RUNTIME_DIR"] = f"/run/user/{target_uid}"
        return subprocess.run(["sudo", "-u", target_user] + cmd, capture_output=True, text=True, check=check, env=env)
    return subprocess.run(cmd, capture_output=True, text=True, check=check)


def is_module_loaded(module_name: str) -> bool:
    name = module_name.replace("-", "_")
    try:
        with open("/proc/modules", "r") as f:
            for line in f:
                if line.startswith(f"{name} "):
                    return True
    except Exception:
        res = subprocess.run(["lsmod"], capture_output=True, text=True)
        return f"\n{name} " in f"\n{res.stdout}"
    return False


def load_module(module_name: str, delay: float = 0.5) -> bool:
    if is_module_loaded(module_name):
        logger.debug(f"Module {module_name} is already loaded.")
        return True

    _log("*", f"Loading module {module_name}...")
    for attempt in range(1, 4):
        if subprocess.run(["modprobe", "--verbose", module_name]).returncode == 0:
            _log("*", f"Module {module_name} loaded (Attempt {attempt}).")
            time.sleep(delay)
            return True
        _log("!", f"Failed to load {module_name}. Retrying... ({attempt}/3)")
        time.sleep(1)
    _log("-", f"CRITICAL: Failed to load module {module_name}.")
    return False


def unload_module(module_name: str, delay: float = 0.5) -> bool:
    if not is_module_loaded(module_name):
        logger.debug(f"Module {module_name} is not loaded.")
        return True

    _log("*", f"Unloading module {module_name}...")
    for attempt in range(1, 6):
        res = subprocess.run(["modprobe", "--verbose", "--remove", "--remove-holders", module_name], capture_output=True, text=True)

        if res.returncode == 0 and not is_module_loaded(module_name):
            _log("*", f"Module {module_name} unloaded (Attempt {attempt}).")
            time.sleep(delay)
            return True
        else:
            if res.stderr:
                _log("!", f"Unload attempt {attempt} failed: {res.stderr.strip()}")
        time.sleep(1)
    _log("-", f"CRITICAL: Failed to unload module {module_name}.")
    return False


def stop_service(service_name: str, wait: bool = False, user_mode: bool = False) -> bool:
    try:
        cmd = ["systemctl"]
        if user_mode:
            cmd.append("--user")
        args: list[str] = [] if wait else ["--no-block"]
        _log("*", f"Stopping {service_name}...")
        run_cmd_wrapper(cmd + ["stop"] + args + [service_name], user_mode=user_mode)
        return True
    except Exception as err:
        _log("-", f"Something went wrong while stopping with: {service_name}: {err}")
        return False


def start_service(service_name: str, wait: bool = False, user_mode: bool = False) -> bool:
    try:
        cmd = ["systemctl"]
        if user_mode:
            cmd.append("--user")
        args = [] if wait else ["--no-block"]
        if run_cmd_wrapper(cmd + ["is-active", "--quiet", service_name], user_mode=user_mode).returncode != 0:
            _log("*", f"Starting {service_name}...")
            run_cmd_wrapper(cmd + ["start"] + args + [service_name], user_mode=user_mode)
            return True
        else:
            _log("*", f"Restarting {service_name}...")
            run_cmd_wrapper(cmd + ["restart"] + args + [service_name], user_mode=user_mode)
            return True
    except Exception as err:
        _log("-", f"Something went wrong while starting with: {service_name}: {err}")
        return False


def rescan_pci() -> bool:
    _log("*", "Rescanning PCI bus...")
    try:
        with open("/sys/bus/pci/rescan", "w") as f:
            f.write("1")
            return True
    except Exception as e:
        _log("-", f"Failed to rescan PCI: {e}")
        return False


def remove_device(device_id: str, name: Optional[str] = None) -> bool:
    path = f"/sys/bus/pci/devices/{device_id}/remove"
    if os.path.exists(path):
        _log("*", f"Removing {name or device_id}...")
        try:
            with open(path, "w") as f:
                f.write("1")
            return True
        except Exception as e:
            _log("-", f"Failed to remove {name or device_id}: {e}")
    return False


def load_sequence() -> None:
    _log("*", "Executing LOAD sequence...")
    load_module("apple-bce", 4)
    load_module("hid_appletb_bl")
    load_module("hid_appletb_kbd")
    load_module("appletbdrm")
    load_module("brcmfmac", 1)
    start_service("NetworkManager", wait=True, user_mode=False)
    load_module("hci_bcm4377", 1)
    start_service("bluetooth.service", wait=True, user_mode=False)
    start_service("tiny-dfr.service", wait=True, user_mode=False)
    rescan_pci()
    load_module("thunderbolt")
    start_service("pipewire.socket", user_mode=True, wait=True)
    start_service("pipewire.service", user_mode=True, wait=True)
    start_service("wireplumber.service", user_mode=True, wait=True)
    _log("*", "LOAD sequence complete.")


def unload_sequence() -> None:
    _log("*", "Executing UNLOAD sequence...")
    stop_service("pipewire.socket", user_mode=True, wait=True)
    stop_service("wireplumber.service", user_mode=True, wait=True)
    stop_service("pipewire.service", user_mode=True, wait=True)
    stop_service("tiny-dfr.service")
    remove_device("0000:06:00.0", "Thunderbolt Controller")
    unload_module("thunderbolt")
    unload_module("appletbdrm")
    unload_module("hid_appletb_bl")
    unload_module("hid_appletb_kbd")
    unload_module("hci_bcm4377", 2)
    stop_service("bluetooth.service", wait=True, user_mode=False)
    unload_module("brcmfmac", 2)
    stop_service("NetworkManager.service", wait=True, user_mode=False)
    unload_module("apple-bce", 4)
    _log("*", "UNLOAD sequence complete.")


def main() -> None:
    t2.check_root()
    parser = argparse.ArgumentParser()
    parser.add_argument("action", choices=["load", "unload", "reload", "version", "v"])
    args = parser.parse_args()
    if args.action in ["version", "v"]:
        print(version)
    elif args.action == "load":
        load_sequence()
    elif args.action == "unload":
        unload_sequence()
    elif args.action == "reload":
        unload_sequence()
        time.sleep(10)
        load_sequence()


if __name__ == "__main__":
    main()
