#!/usr/bin/env python3
#
#  suspendfix
#  T2_Linux
#
#  Created by turannul on 10/12/2025.
#  Rewritten in Python on 07/02/2026.
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; version 2 of the License.
#
#  See the LICENSE file for more details.

import argparse
import logging
import os
import subprocess
import sys
import time
from typing import List, Optional

try:
    import t2
except ImportError:
    # Add parent directory to sys.path to find t2 when running from repo
    sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
    import t2

# constants
version = "0.5.2"
# initialize global logger
logger = t2.setup_logging("SuspendFix", level=logging.DEBUG)


def _log(char, msg) -> None:
    t2.log_event(logger, char, msg)


def get_active_user() -> tuple[None, None] | tuple[str, str]:
    try:
        output: str = subprocess.check_output(["loginctl", "list-users", "--no-legend"], text=True).strip()
        if not output:
            return None, None
        parts: List[str] = output.splitlines()[0].split()
        if len(parts) >= 2:
            user: str = parts[1]
            uid: str = subprocess.check_output(["id", "-u", user], text=True).strip()
            return user, uid
    except Exception as e:
        logger.debug(f"Failed to get active user: {e}")
    return None, None


target_user, target_uid = get_active_user()


def run_cmd_wrapper(cmd: List[str], check: bool = False, as_user: bool = False):
    if as_user:
        if not target_user:
            logger.warning(f"No active user found for command: {' '.join(cmd)}")
            return subprocess.CompletedProcess(cmd, 1)
        env: dict[str, str] = os.environ.copy()
        env["XDG_RUNTIME_DIR"] = f"/run/user/{target_uid}"
        env["DBUS_SESSION_BUS_ADDRESS"] = f"unix:path=/run/user/{target_uid}/bus"

        full_cmd = ["sudo", "-E", "-u", target_user] + cmd
        # _log("#", f"Running as {target_user}: {' '.join(full_cmd)}")
        res = subprocess.run(full_cmd, capture_output=True, text=True, check=check, env=env)
        if res.returncode != 0:
            _log("!", f"Command failed (Code {res.returncode}): {res.stderr.strip()}")
        return res
    return subprocess.run(cmd, capture_output=True, text=True, check=check)


def is_module_loaded(module_name: str) -> bool:
    name = module_name.replace("-", "_")
    try:
        with open("/proc/modules", "r") as f:
            for line in f:
                if line.startswith(f"{name} "):
                    return True
    except Exception:
        res = subprocess.run(["lsmod"], capture_output=True, text=True)
        return f"\n{name} " in f"\n{res.stdout}"
    return False


def load_module(module_name: str, delay: float = 0.5) -> bool:
    if is_module_loaded(module_name):
        logger.debug(f"Module {module_name} is already loaded.")
        return True

    _log("*", f"Loading module {module_name}...")
    for attempt in range(1, 4):
        if subprocess.run(["modprobe", "--verbose", module_name]).returncode == 0:
            _log("*", f"Module {module_name} loaded (Attempt {attempt}).")
            time.sleep(delay)
            return True
        _log("!", f"Failed to load {module_name}. Retrying... ({attempt}/3)")
        time.sleep(1)
    _log("-", f"CRITICAL: Failed to load module {module_name}.")
    return False


def unload_module(module_name: str, delay: float = 0.5) -> bool:
    if not is_module_loaded(module_name):
        logger.debug(f"Module {module_name} is not loaded.")
        return True

    _log("*", f"Unloading module {module_name}...")
    for attempt in range(1, 4):
        res = subprocess.run(["modprobe", "--verbose", "--remove", "--remove-holders", module_name], capture_output=True, text=True)

        if res.returncode == 0 and not is_module_loaded(module_name):
            _log("*", f"Module {module_name} unloaded (Attempt {attempt}).")
            time.sleep(delay)
            return True
        else:
            if res.stderr:
                _log("!", f"Unload attempt {attempt} failed: {res.stderr.strip()}")
        time.sleep(1)
    _log("-", f"CRITICAL: Failed to unload module {module_name}.")
    return False


def stop_service(service_name: str, block: bool = True, as_user: bool = False) -> bool:
    """Stops a systemd service, optionally blocking until it's stopped, with verification and retry logic."""
    try:
        cmd = ["systemctl"]
        if as_user:
            cmd.append("--user")
        stop_args = [] if block else ["--no-block"]

        _log("*", f"Stopping {service_name}...")
        # Attempt to stop the service
        for attempt in range(1, 4):
            run_cmd_wrapper(cmd + ["stop"] + stop_args + [service_name], as_user=as_user)
            if block:
                # Check if it's actually stopped
                if run_cmd_wrapper(cmd + ["is-active", "--quiet", service_name], as_user=as_user).returncode != 0:
                    _log("+", f"Service {service_name} stopped.")
                    return True
                else:
                    _log("!", f"Service {service_name} still active after stop attempt {attempt}. Retrying...")
                    time.sleep(1)
            else:
                # If non-blocking, we just fire and forget
                return True

        _log("-", f"Failed to stop {service_name} after 3 attempts.")
        return False

    except Exception as err:
        _log("-", f"Something went wrong while stopping {service_name}: {err}")
        return False


def start_service(service_name: str, block: bool = False, as_user: bool = False) -> bool:
    """Starts or restarts a systemd service with verification and retry logic."""
    try:
        cmd = ["systemctl"]
        if as_user:
            cmd.append("--user")
        start_args = [] if block else ["--no-block"]

        # Check if active to decide between start and restart
        is_active = run_cmd_wrapper(cmd + ["is-active", "--quiet", service_name], as_user=as_user).returncode == 0
        action = "restart" if is_active else "start"
        _log("*", f"{action.capitalize()}ing {service_name}...")
        for attempt in range(1, 4):
            run_cmd_wrapper(cmd + [action] + start_args + [service_name], as_user=as_user)
            if block:
                # Verify it started
                if run_cmd_wrapper(cmd + ["is-active", "--quiet", service_name], as_user=as_user).returncode == 0:
                    _log("+", f"Service {service_name} {action}ed successfully.")
                    return True
                else:
                    _log("!", f"Service {service_name} failed to {action} (Attempt {attempt}). Retrying...")
                    time.sleep(1)
            else:
                return True

        _log("-", f"Failed to {action} {service_name} after 3 attempts.")
        return False

    except Exception as err:
        _log("-", f"Something went wrong while starting {service_name}: {err}")
        return False


def rescan_pci() -> bool:
    _log("*", "Rescanning PCI bus...")
    try:
        with open("/sys/bus/pci/rescan", "w") as f:
            f.write("1")
            return True
    except Exception as e:
        _log("-", f"Failed to rescan PCI: {e}")
        return False


def remove_device(device_id: str, name: Optional[str] = None) -> bool:
    path = f"/sys/bus/pci/devices/{device_id}/remove"
    if os.path.exists(path):
        _log("*", f"Removing {name or device_id}...")
        try:
            with open(path, "w") as f:
                f.write("1")
            return True
        except Exception as e:
            _log("-", f"Failed to remove {name or device_id}: {e}")
    return False


def load_sequence() -> None:
    _log("*", "Executing LOAD sequence...")
    load_module("apple-bce", 4)
    load_module("hid_appletb_bl")
    load_module("hid_appletb_kbd")
    load_module("appletbdrm")
    load_module("brcmfmac_wcc", 1)
    start_service("NetworkManager", block=True, as_user=False)
    load_module("hci_bcm4377", 1)
    start_service("bluetooth.service", block=True, as_user=False)
    start_service("tiny-dfr.service", block=False, as_user=False)
    rescan_pci()
    load_module("thunderbolt")
    start_service("pipewire-pulse.service", block=False, as_user=True)
    start_service("pipewire.socket", block=False, as_user=True)
    start_service("pipewire.service", block=False, as_user=True)
    start_service("wireplumber.service", block=False, as_user=True)
    _log("*", "LOAD sequence complete.")


def unload_sequence() -> None:
    _log("*", "Executing UNLOAD sequence...")
    stop_service("pipewire-pulse.service", as_user=True)
    stop_service("pipewire.socket", as_user=True)
    stop_service("wireplumber.service", as_user=True)
    stop_service("pipewire.service", as_user=True)
    stop_service("tiny-dfr.service", block=True, as_user=False)
    remove_device("0000:06:00.0", "Thunderbolt Controller")
    unload_module("thunderbolt")
    unload_module("appletbdrm")
    unload_module("hid_appletb_bl")
    unload_module("hid_appletb_kbd")
    unload_module("hci_bcm4377", 2)
    stop_service("bluetooth.service", block=True, as_user=False)
    unload_module("brcmfmac_wcc", 2)
    stop_service("NetworkManager.service", block=True, as_user=False)
    unload_module("apple-bce", 4)
    _log("*", "UNLOAD sequence complete.")


def main() -> None:
    t2.check_root()
    parser = argparse.ArgumentParser()
    parser.add_argument("action", choices=["load", "unload", "reload", "version", "v"])
    args = parser.parse_args()
    if args.action in ["version", "v"]:
        print(version)
    elif args.action == "load":
        load_sequence()
    elif args.action == "unload":
        unload_sequence()
    elif args.action == "reload":
        unload_sequence()
        time.sleep(10)
        load_sequence()


if __name__ == "__main__":
    main()
