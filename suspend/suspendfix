#!/usr/bin/env python3
import argparse
import logging
import os
import subprocess
import sys
import time
from typing import List, Optional

# Constants
LOG_FILE = "/var/log/suspend-fix-t2.log"
VERSION = "0.4"


class SuspendFix:
    def __init__(self):
        self.setup_logging()
        self.target_user, self.target_uid = self._get_active_user()

    def setup_logging(self):
        logging.basicConfig(
            level=logging.INFO,
            format="[%(asctime)s] [%(levelname)s] %(message)s",
            datefmt="%Y-%m-%d %H:%M:%S",
            handlers=[
                logging.FileHandler(LOG_FILE),
                logging.StreamHandler(sys.stdout),
            ],
        )
        self.logger = logging.getLogger("SuspendFix")

    def _get_active_user(self) -> tuple[Optional[str], Optional[str]]:
        try:
            output = subprocess.check_output(
                ["loginctl", "list-users", "--no-legend"], text=True
            ).strip()
            if not output:
                return None, None
            first_line = output.splitlines()[0]
            parts = first_line.split()
            if len(parts) >= 2:
                user = parts[1]
                uid = subprocess.check_output(["id", "-u", user], text=True).strip()
                return user, uid
        except Exception as e:
            self.logger.debug(f"Failed to get active user: {e}")
        return None, None

    def _run_cmd(
        self, cmd: List[str], check: bool = False, user_mode: bool = False
    ) -> subprocess.CompletedProcess:
        if user_mode:
            if not self.target_user:
                self.logger.warning(f"No active user found for command: {' '.join(cmd)}")
                return subprocess.CompletedProcess(cmd, 1)
            env = os.environ.copy()
            env["XDG_RUNTIME_DIR"] = f"/run/user/{self.target_uid}"
            full_cmd = ["sudo", "-u", self.target_user] + cmd
            return subprocess.run(
                full_cmd, capture_output=True, text=True, check=check, env=env
            )
        return subprocess.run(cmd, capture_output=True, text=True, check=check)

    def is_module_loaded(self, module_name: str) -> bool:
        module_name = module_name.replace("-", "_")
        try:
            with open("/proc/modules", "r") as f:
                for line in f:
                    if line.startswith(f"{module_name} "):
                        return True
        except Exception:
            # Fallback to lsmod
            res = subprocess.run(["lsmod"], capture_output=True, text=True)
            return f"\n{module_name} " in f"\n{res.stdout}"
        return False

    def load_module(self, module_name: str, delay: float = 0.5):
        if self.is_module_loaded(module_name):
            self.logger.debug(f"Module {module_name} is already loaded, skipping.")
            return True

        self.logger.info(f"Loading module {module_name}...")
        max_retries = 3
        for attempt in range(1, max_retries + 1):
            res = subprocess.run(["modprobe", module_name])
            if res.returncode == 0:
                self.logger.info(f"Module {module_name} loaded (Attempt {attempt}).")
                self.logger.info(f"Waiting {delay}s for initialization...")
                time.sleep(delay)
                return True
            self.logger.warning(
                f"Failed to load {module_name}. Retrying in 1s... ({attempt}/{max_retries})"
            )
            time.sleep(1)

        self.logger.error(
            f"CRITICAL: Failed to load module {module_name} after {max_retries} attempts."
        )
        return False

    def unload_module(self, module_name: str, delay: float = 0.5):
        mod_name_canonical = module_name.replace("-", "_")
        if not self.is_module_loaded(module_name):
            self.logger.debug(f"Module {module_name} is not loaded, skipping.")
            return True

        self.logger.info(f"Unloading module {module_name}...")
        max_retries = 5
        for attempt in range(1, max_retries + 1):
            if module_name == "apple-bce" or mod_name_canonical == "apple_bce":
                res = subprocess.run(["rmmod", module_name], capture_output=True)
            else:
                res = subprocess.run(
                    ["modprobe", "--remove", "--remove-holders", module_name],
                    capture_output=True,
                )

            if res.returncode == 0:
                if not self.is_module_loaded(module_name):
                    self.logger.info(
                        f"Module {module_name} unloaded successfully (Attempt {attempt})."
                    )
                    self.logger.info(f"Waiting {delay}s for deinitialization...")
                    time.sleep(delay)
                    return True

            self.logger.warning(
                f"Module {module_name} busy or failed to unload. Retrying in 1s... ({attempt}/{max_retries})"
            )
            time.sleep(1)

        self.logger.error(f"CRITICAL: Failed to unload module {module_name}.")
        return False

    def stop_service(self, service_name: str, user_mode: bool = False):
        cmd = ["systemctl"]
        if user_mode:
            cmd.append("--user")

        res = self._run_cmd(cmd + ["is-active", "--quiet", service_name], user_mode=user_mode)
        if res.returncode == 0:
            self.logger.info(f"Stopping {service_name}...")
            self._run_cmd(cmd + ["stop", service_name], user_mode=user_mode)

    def start_service(self, service_name: str, wait: bool = True, user_mode: bool = False):
        cmd = ["systemctl"]
        if user_mode:
            cmd.append("--user")

        ctl_args = []
        if not wait:
            ctl_args.append("--no-block")

        res = self._run_cmd(cmd + ["is-active", "--quiet", service_name], user_mode=user_mode)
        if res.returncode != 0:
            self.logger.info(f"Starting {service_name}...")
            self._run_cmd(cmd + ["start"] + ctl_args + [service_name], user_mode=user_mode)
        else:
            self.logger.info(f"{service_name} is already running, restarting...")
            self._run_cmd(cmd + ["restart"] + ctl_args + [service_name], user_mode=user_mode)

    def rescan_pci(self):
        self.logger.info("Rescanning PCI bus...")
        try:
            with open("/sys/bus/pci/rescan", "w") as f:
                f.write("1")
            self.logger.info("PCI rescan triggered successfully.")
        except Exception as e:
            self.logger.error(f"Failed to trigger PCI rescan: {e}")

    def remove_device(self, device_id: str, device_name: Optional[str] = None):
        name = device_name or f"device {device_id}"
        remove_path = f"/sys/bus/pci/devices/{device_id}/remove"

        if os.path.exists(remove_path):
            self.logger.info(f"Removing {name}...")
            try:
                with open(remove_path, "w") as f:
                    f.write("1")
                if not os.path.exists(f"/sys/bus/pci/devices/{device_id}"):
                    self.logger.info(f"Removed {name} successfully.")
                    return True
            except Exception as e:
                self.logger.error(f"Failed to remove {name}: {e}")
        else:
            self.logger.warning(f"{name} not found, skipping removal.")
        return False

    def load_sequence(self):
        self.logger.info("###########################")
        self.logger.info("Executing LOAD sequence...")
        self.logger.info("###########################")

        self.logger.info("PHASE 1: Root Modules")
        self.load_module("apple-bce", 4)

        self.logger.info("PHASE 2: Peripheral Modules")
        self.load_module("hid_appletb_bl")
        self.load_module("hid_appletb_kbd")
        self.load_module("appletbdrm")
        self.load_module("brcmfmac", 1)
        self.load_module("brcmfmac_wcc", 2)
        self.load_module("hci_bcm4377", 1)

        self.logger.info("PHASE 3: Services & Hardware Wake")
        self.start_service("tiny-dfr.service", wait=False)
        self.rescan_pci()

        self.logger.info("PHASE 4: Thunderbolt & Audio")
        self.load_module("thunderbolt")

        self.start_service("pipewire.socket", wait=False, user_mode=True)
        self.start_service("pipewire.service", wait=False, user_mode=True)
        self.start_service("wireplumber.service", wait=False, user_mode=True)

        self.logger.info("LOAD sequence complete.")

    def unload_sequence(self):
        self.logger.info("###########################")
        self.logger.info("Executing UNLOAD sequence...")
        self.logger.info("###########################")

        self.logger.info("PHASE 1: Stop Services")
        self.stop_service("wireplumber.service", user_mode=True)
        self.stop_service("pipewire.socket", user_mode=True)
        self.stop_service("pipewire.service", user_mode=True)
        self.stop_service("tiny-dfr.service")

        self.logger.info("PHASE 2: Hardware Teardown (Thunderbolt)")
        self.remove_device("0000:06:00.0", "Thunderbolt Controller")
        self.unload_module("thunderbolt")

        self.logger.info("PHASE 3: Unload Leaf Modules")
        self.unload_module("appletbdrm")
        self.unload_module("hid_appletb_bl")
        self.unload_module("hid_appletb_kbd")
        self.unload_module("hci_bcm4377", 2)
        self.unload_module("brcmfmac_wcc", 2)
        self.unload_module("brcmfmac", 2)

        self.logger.info("PHASE 4: Unload Root Module")
        self.unload_module("apple-bce", 4)

        self.logger.info("UNLOAD sequence complete.")

    def reload_sequence(self):
        self.unload_sequence()
        time.sleep(10)
        self.load_sequence()


def main():
    if os.geteuid() != 0:
        os.execvp("sudo", ["sudo", "python3"] + sys.argv)

    parser = argparse.ArgumentParser(description="T2 Linux Suspend Fix")
    parser.add_argument(
        "action", choices=["load", "unload", "reload", "version", "v"], help="Action to perform"
    )
    args = parser.parse_args()

    fix = SuspendFix()

    if args.action in ["version", "v"]:
        print(VERSION)
    elif args.action == "load":
        fix.load_sequence()
    elif args.action == "unload":
        fix.unload_sequence()
    elif args.action == "reload":
        fix.reload_sequence()


if __name__ == "__main__":
    main()
