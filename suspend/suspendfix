#!/usr/bin/env python3
import argparse
import os
import subprocess
import sys
import time
from typing import List, Optional

# constants
log_file = "/var/log/suspend-fix-t2.log"
version = "0.4"

# import common utils
sys.path.append("/usr/local/lib/t2linux")
try:
    import t2
except ImportError:
    # fallback for dev environment
    script_dir = os.path.dirname(os.path.abspath(__file__))
    sys.path.append(os.path.join(script_dir, "..", "common"))
    try:
        import t2
    except ImportError:
        print("Error: Could not import t2.py.")
        sys.exit(1)

# initialize global logger
logger = t2.setup_logging(log_file, "SuspendFix")


def _log(char, msg):
    t2.log_event(logger, char, msg)


def get_active_user():
    try:
        output = subprocess.check_output(["loginctl", "list-users", "--no-legend"], text=True).strip()
        if not output:
            return None, None
        parts = output.splitlines()[0].split()
        if len(parts) >= 2:
            user = parts[1]
            uid = subprocess.check_output(["id", "-u", user], text=True).strip()
            return user, uid
    except Exception as e:
        logger.debug(f"Failed to get active user: {e}")
    return None, None


target_user, target_uid = get_active_user()


def run_cmd_wrapper(cmd: List[str], check: bool = False, user_mode: bool = False):
    if user_mode:
        if not target_user:
            logger.warning(f"No active user found for command: {' '.join(cmd)}")
            return subprocess.CompletedProcess(cmd, 1)
        env = os.environ.copy()
        env["XDG_RUNTIME_DIR"] = f"/run/user/{target_uid}"
        full_cmd = ["sudo", "-u", target_user] + cmd
        return subprocess.run(full_cmd, capture_output=True, text=True, check=check, env=env)
    return subprocess.run(cmd, capture_output=True, text=True, check=check)


def is_module_loaded(module_name: str):
    name = module_name.replace("-", "_")
    try:
        with open("/proc/modules", "r") as f:
            for line in f:
                if line.startswith(f"{name} "):
                    return True
    except Exception:
        res = subprocess.run(["lsmod"], capture_output=True, text=True)
        return f"\n{name} " in f"\n{res.stdout}"
    return False


def load_module(module_name: str, delay: float = 0.5):
    if is_module_loaded(module_name):
        logger.debug(f"Module {module_name} is already loaded.")
        return True

    _log("*", f"Loading module {module_name}...")
    for attempt in range(1, 4):
        if subprocess.run(["modprobe", "--verbose", module_name]).returncode == 0:
            _log("*", f"Module {module_name} loaded (Attempt {attempt}).")
            time.sleep(delay)
            return True
        _log("!", f"Failed to load {module_name}. Retrying... ({attempt}/3)")
        time.sleep(1)
    _log("-", f"CRITICAL: Failed to load module {module_name}.")
    return False


def unload_module(module_name: str, delay: float = 0.5):
    if not is_module_loaded(module_name):
        logger.debug(f"Module {module_name} is not loaded.")
        return True

    _log("*", f"Unloading module {module_name}...")
    for attempt in range(1, 6):
        res = subprocess.run(["modprobe", "--verbose", "--remove", "--remove-holders", module_name], capture_output=True, text=True)

        if res.returncode == 0 and not is_module_loaded(module_name):
            _log("*", f"Module {module_name} unloaded (Attempt {attempt}).")
            time.sleep(delay)
            return True
        else:
            if res.stderr:
                _log("!", f"Unload attempt {attempt} failed: {res.stderr.strip()}")
        time.sleep(1)
    _log("-", f"CRITICAL: Failed to unload module {module_name}.")
    return False


def stop_service(service_name: str, wait: bool = False, user_mode: bool = False):
    try:
        cmd = ["systemctl"]
        if user_mode:
            cmd.append("--user")
        args: list[str] = [] if wait else ["--no-block"]
        _log("*", f"Stopping {service_name}...")
        run_cmd_wrapper(cmd + ["stop"] + args + [service_name], user_mode=user_mode)
        return True
    except Exception as err:
        _log("-", f"Something went wrong while stopping with: {service_name}: {err}")
        return False


def start_service(service_name: str, wait: bool = False, user_mode: bool = False):
    cmd = ["systemctl"]
    if user_mode:
        cmd.append("--user")
    args = [] if wait else ["--no-block"]
    if run_cmd_wrapper(cmd + ["is-active", "--quiet", service_name], user_mode=user_mode).returncode != 0:
        _log("*", f"Starting {service_name}...")
        run_cmd_wrapper(cmd + ["start"] + args + [service_name], user_mode=user_mode)
    else:
        _log("*", f"Restarting {service_name}...")
        run_cmd_wrapper(cmd + ["restart"] + args + [service_name], user_mode=user_mode)


def rescan_pci():
    _log("*", "Rescanning PCI bus...")
    try:
        with open("/sys/bus/pci/rescan", "w") as f:
            f.write("1")
    except Exception as e:
        _log("-", f"Failed to rescan PCI: {e}")


def remove_device(device_id: str, name: Optional[str] = None):
    path = f"/sys/bus/pci/devices/{device_id}/remove"
    if os.path.exists(path):
        _log("*", f"Removing {name or device_id}...")
        try:
            with open(path, "w") as f:
                f.write("1")
            return True
        except Exception as e:
            _log("-", f"Failed to remove {name or device_id}: {e}")
    return False


def load_sequence():
    _log("_", "###########################")
    _log("*", "Executing LOAD sequence...")
    _log("_", "###########################")
    load_module("apple-bce", 4)
    load_module("hid_appletb_bl")
    load_module("hid_appletb_kbd")
    load_module("appletbdrm")
    load_module("brcmfmac", 1)
    start_service("NetworkManager", wait=True, user_mode=False)
    load_module("brcmfmac_wcc", 1)
    load_module("hci_bcm4377", 1)
    start_service("tiny-dfr.service", wait=True, user_mode=False)
    rescan_pci()
    load_module("thunderbolt")
    start_service("pipewire.service", user_mode=True, wait=True)
    start_service("wireplumber.service", user_mode=True, wait=True)
    _log("*", "LOAD sequence complete.")


def unload_sequence():
    _log("_", "###########################")
    _log("*", "Executing UNLOAD sequence...")
    _log("_", "###########################")
    for svc in ["wireplumber.service", "pipewire.service", "pipewire.socket"]:
        stop_service(svc, user_mode=True, wait=True)
    stop_service("tiny-dfr.service", wait=True)
    remove_device("0000:06:00.0", "Thunderbolt Controller")
    unload_module("thunderbolt")
    unload_module("appletbdrm")
    unload_module("hid_appletb_bl")
    unload_module("hid_appletb_kbd")
    unload_module("hci_bcm4377", 2)
    stop_service("bluetooth.service", wait=True, user_mode=False)
    unload_module("brcmfmac", 2)
    stop_service("NetworkManager.service", wait=True, user_mode=False)
    unload_module("apple-bce", 4)
    _log("*", "UNLOAD sequence complete.")


def main():
    t2.check_root()
    parser = argparse.ArgumentParser()
    parser.add_argument("action", choices=["load", "unload", "reload", "version", "v"])
    args = parser.parse_args()
    if args.action in ["version", "v"]:
        print(version)
    elif args.action == "load":
        load_sequence()
    elif args.action == "unload":
        unload_sequence()
    elif args.action == "reload":
        unload_sequence()
        time.sleep(10)
        load_sequence()


if __name__ == "__main__":
    main()